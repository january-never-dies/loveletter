<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>B Scroll</title>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      -webkit-font-smoothing: antialiased;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    #viewport {
      position: fixed;
      inset: 0;
      background: #000;
      overflow: hidden;
    }

    /* 캔버스 기반으로 index.html과 통일성 유지 */
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #goHit {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
    }

    #goHit.enabled {
      pointer-events: auto;
      cursor: pointer;
    }

    #topHint {
      position: fixed;
      top: max(14px, env(safe-area-inset-top));
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.6);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      transition: opacity 350ms ease;
    }

    #topHint.show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="topHint">탭해서 GO! 버튼을 찾아요</div>

  <div id="viewport">
    <canvas id="base"></canvas>
    <canvas id="fade"></canvas>
    <div id="goHit" aria-label="Go"></div>
  </div>

  <script>
    const SEQ = [
      "assets/b1.webp", "assets/b2.webp", "assets/b3.webp", "assets/b4.webp",
      "assets/b5.webp", "assets/b6.webp", "assets/b7.webp", "assets/b8.webp",
      "assets/b9.webp", "assets/b10.webp", "assets/b11.webp", "assets/b12.webp",
      "assets/b13.webp", "assets/b14.webp", "assets/button_go.webp"
    ];

    const FADE_MS = 600;
    const DPR_CAP = 2;

    const topHint = document.getElementById("topHint");
    const base = document.getElementById("base");
    const fade = document.getElementById("fade");
    const goHit = document.getElementById("goHit");
    const bctx = base.getContext("2d", { alpha: false });
    const fctx = fade.getContext("2d");

    let currentIdx = 0;
    let isTransitioning = false;

    function resizeCanvases() {
      const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
      const w = window.innerWidth * dpr;
      const h = window.innerHeight * dpr;
      base.width = w; base.height = h;
      fade.width = w; fade.height = h;

      bctx.fillStyle = "#000";
      bctx.fillRect(0, 0, w, h);
      renderCurrentState();
    }

    function drawCover(ctx, img, cw, ch) {
      if (!img) return;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const scale = Math.max(cw / iw, ch / ih);
      const sw = cw / scale;
      const sh = ch / scale;
      const sx = (iw - sw) / 2;
      const sy = (ih - sh) / 2;
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
    }

    const imageCache = {};
    async function loadImage(src) {
      if (imageCache[src]) return imageCache[src];
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          imageCache[src] = img;
          resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = src;
      });
    }

    async function renderCurrentState() {
      const img = await loadImage(SEQ[currentIdx]);
      if (img) drawCover(bctx, img, base.width, base.height);
    }

    async function advance() {
      if (isTransitioning) return;

      // 마지막(버튼) 인덱스면 클릭 이벤트(goHit)에서 처리하므로 advance 무시
      if (currentIdx >= SEQ.length - 1) return;

      isTransitioning = true;
      topHint.classList.remove("show");

      const nextIdx = currentIdx + 1;
      const nextImg = await loadImage(SEQ[nextIdx]);

      if (!nextImg) {
        currentIdx = nextIdx;
        isTransitioning = false;
        return;
      }

      const cw = base.width, ch = base.height;
      const t0 = performance.now();

      return new Promise((resolve) => {
        function tick(now) {
          const p = Math.min(1, (now - t0) / FADE_MS);

          fctx.clearRect(0, 0, cw, ch);
          fctx.globalAlpha = p;
          drawCover(fctx, nextImg, cw, ch);

          if (p < 1) {
            requestAnimationFrame(tick);
          } else {
            bctx.globalAlpha = 1;
            drawCover(bctx, nextImg, cw, ch);
            fctx.clearRect(0, 0, cw, ch);

            currentIdx = nextIdx;
            isTransitioning = false;

            // 마지막 버튼 이미지면 히트 영역 활성화
            if (currentIdx === SEQ.length - 1) {
              goHit.classList.add("enabled");
            } else {
              topHint.classList.add("show");
            }
            resolve();
          }
        }
        requestAnimationFrame(tick);
      });
    }

    window.addEventListener("click", advance);

    goHit.addEventListener("click", (e) => {
      if (!goHit.classList.contains("enabled")) return;
      e.preventDefault();
      e.stopPropagation(); // advance 실행 방지
      location.href = "sticker.html";
    });

    window.addEventListener("load", async () => {
      resizeCanvases();
      const firstImg = await loadImage(SEQ[0]);
      if (firstImg) {
        drawCover(bctx, firstImg, base.width, base.height);
      }
      setTimeout(() => topHint.classList.add("show"), 500);
    });

    window.addEventListener("resize", () => {
      resizeCanvases();
    });
  </script>
</body>

</html>