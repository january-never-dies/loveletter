<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>A Sequence</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* 스크롤 포기 */
      background: #000;
      -webkit-font-smoothing: antialiased;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* 화면을 390x844 비율로 "꽉 차게(cover)" */
    #viewport {
      position: fixed;
      inset: 0;
      background: #000;
      overflow: hidden;
    }

    /* 캔버스는 화면 전체, 내부는 DPR 스케일 */
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #loading {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      z-index: 10;
      transition: opacity 250ms ease;
    }

    #loading.hide {
      opacity: 0;
      pointer-events: none;
    }

    #hint {
      position: absolute;
      left: 0;
      bottom: max(24px, env(safe-area-inset-bottom));
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      letter-spacing: 0.2px;
      opacity: 0;
      transition: opacity 350ms ease;
      pointer-events: none;
      z-index: 5;
    }

    #hint.show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="loading">Loading…</div>

  <div id="viewport">
    <!-- 누적 합성(배경) -->
    <canvas id="base"></canvas>
    <!-- 페이드 인(상단) -->
    <canvas id="fade"></canvas>

    <div id="hint">탭해서 다음으로</div>
  </div>

  <script>
    const A_SEQ = [
      "assets/a1.webp", "assets/a2.webp", "assets/a3.webp", "assets/a4.webp", "assets/a5.webp", "assets/a6.webp",
      "assets/a7.webp", "assets/a8.webp", "assets/a9.webp", "assets/a10.webp", "assets/a11.webp", "assets/a12.webp", "assets/a13.webp"
    ];

    const FADE_MS = 600;
    const DPR_CAP = 2;

    const loading = document.getElementById("loading");
    const hint = document.getElementById("hint");
    const base = document.getElementById("base");
    const fade = document.getElementById("fade");
    const bctx = base.getContext("2d", { alpha: false });
    const fctx = fade.getContext("2d");

    let currentIdx = 0;
    let isTransitioning = false;

    function resizeCanvases() {
      const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
      const w = window.innerWidth * dpr;
      const h = window.innerHeight * dpr;
      base.width = w; base.height = h;
      fade.width = w; fade.height = h;

      bctx.fillStyle = "#000";
      bctx.fillRect(0, 0, w, h);

      // 리사이즈 시 현재까지의 상태를 유지하려면 복잡해지므로, 
      // 현재 인덱스의 이미지를 다시 그려주는 정도로 처리
      if (currentIdx >= 0) {
        renderCurrentState();
      }
    }

    function drawCover(ctx, img, cw, ch) {
      if (!img) return;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const scale = Math.max(cw / iw, ch / ih);
      const sw = cw / scale;
      const sh = ch / scale;
      const sx = (iw - sw) / 2;
      const sy = (ih - sh) / 2;
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
    }

    const imageCache = {};
    async function loadImage(src) {
      if (imageCache[src]) return imageCache[src];
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          imageCache[src] = img;
          resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = src;
      });
    }

    async function renderCurrentState() {
      const img = await loadImage(A_SEQ[currentIdx]);
      if (img) drawCover(bctx, img, base.width, base.height);
    }

    async function advance() {
      if (isTransitioning) return;

      if (currentIdx >= A_SEQ.length - 1) {
        location.href = "b.html";
        return;
      }

      isTransitioning = true;
      hint.classList.remove("show");

      const nextIdx = currentIdx + 1;
      const nextImg = await loadImage(A_SEQ[nextIdx]);

      if (!nextImg) {
        currentIdx = nextIdx;
        isTransitioning = false;
        return;
      }

      const cw = base.width, ch = base.height;
      const t0 = performance.now();

      return new Promise((resolve) => {
        function tick(now) {
          const p = Math.min(1, (now - t0) / FADE_MS);

          fctx.clearRect(0, 0, cw, ch);
          fctx.globalAlpha = p;
          drawCover(fctx, nextImg, cw, ch);

          if (p < 1) {
            requestAnimationFrame(tick);
          } else {
            // Commit to base
            bctx.globalAlpha = 1;
            drawCover(bctx, nextImg, cw, ch);
            fctx.clearRect(0, 0, cw, ch);

            currentIdx = nextIdx;
            isTransitioning = false;
            hint.classList.add("show");
            resolve();
          }
        }
        requestAnimationFrame(tick);
      });
    }

    window.addEventListener("click", advance);

    window.addEventListener("load", async () => {
      resizeCanvases();
      const firstImg = await loadImage(A_SEQ[0]);
      if (firstImg) {
        drawCover(bctx, firstImg, base.width, base.height);
      }
      loading.classList.add("hide");
      setTimeout(() => hint.classList.add("show"), 1000);
    });

    window.addEventListener("resize", () => {
      resizeCanvases();
    });
  </script>
</body>

</html>