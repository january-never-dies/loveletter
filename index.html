<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Prologue</title>
  <style>
    html,
    body {
      margin: 0;
      background: #fff;
      overflow-x: hidden;
      /* 끝에서 튕기는 느낌을 줄여 더 정확한 느낌을 줌 */
      overscroll-behavior-y: auto;
    }

    /* 중앙 정렬 */
    .wrap {
      width: 100vw;
      display: flex;
      justify-content: center;
      background: #fff;
    }

    /*
      "처음 로드시" 딱 1화면(844px 기준 디자인)을 보여주는 프레임.
    */
    .frame {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #fff;
    }

    @supports (height: 100dvh) {
      .frame {
        height: 100dvh;
      }
    }

    /* 긴 캔버스 무대(레이어가 겹쳐지는 곳) */
    .stage {
      position: absolute;
      inset: 0;
      width: 100%;
      transform: translate3d(0, 0, 0);
      will-change: transform;
    }

    /* 레이어: 전부 '캔버스 전체 크기' PNG라서 (0,0)에 겹치기만 하면 됨 */
    .layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: top center;

      opacity: 0;
      /* 조금 더 아래에서 올라오게 하여 더 부드러운 느낌 */
      transform: translateY(30px);
      /* transition bezier 곡선을 더 부드럽게 조정 */
      transition:
        opacity 1200ms cubic-bezier(0.25, 0.1, 0.25, 1),
        transform 1200ms cubic-bezier(0.25, 0.1, 0.25, 1);

      /* 메모리 최적화를 위해 will-change 제거 */
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* 버튼 레이어 자체의 클릭 비활성화 (전체 화면이 잡히는 문제 해결) */
    .layer[src*="button.png"] {
      pointer-events: none;
    }

    /* 새로운 GO! 버튼 전용 히트 영역 */
    .go-hit-area {
      position: absolute;
      bottom: 2%;
      right: 5%;
      width: 140px;
      height: 140px;
      z-index: 999;
      cursor: pointer;
      display: none;
      /* 스크롤 끝 근처에서만 활성화 */
    }

    .layer.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* 스크롤 길이를 만들어주는 투명 스페이서 */
    .spacer {
      width: 100%;
      background: #fff;
    }
  </style>
</head>

<body>

  <!-- 보이는 프레임 -->
  <div class="wrap" id="main-wrap">
    <div class="frame" id="frame">
      <div class="stage" id="stage">

        <!-- P1 -->
        <img class="layer" data-start="0" src="assets/tx_p101.png" alt="">
        <img class="layer" data-start="70" src="assets/st_p1_01.png" alt="">
        <img class="layer" data-start="140" src="assets/mt_leeseo.png" alt="">
        <img class="layer" data-start="210" src="assets/tx_hsp1.png" alt="">
        <img class="layer" data-start="280" src="assets/st_p1_02.png" alt="">
        <img class="layer" data-start="350" src="assets/mt_lhs.png" alt="">
        <img class="layer" data-start="420" src="assets/mt_hyunddeo.png" alt="">
        <img class="layer" data-start="490" src="assets/mt_ddeoddeo.png" alt="">
        <img class="layer" data-start="560" src="assets/tx_twenty.png" alt="">
        <img class="layer" data-start="630" src="assets/mt_monkey.png" alt="">
        <img class="layer" data-start="700" src="assets/mt_babytiger.png" alt="">
        <img class="layer" data-start="770" src="assets/tx_bdp1.png" alt="">
        <img class="layer" data-start="820" src="assets/mt_babypig.png" alt="">
        <img class="layer" data-start="860" src="assets/st_cupcake.png" alt="">

        <!-- P2~ -->
        <img class="layer" data-start="980" src="assets/tx_celebrate.png" alt="">
        <img class="layer" data-start="1080" src="assets/tx_letter.png" alt="">
        <img class="layer" data-start="1180" src="assets/tx_talk1.png" alt="">
        <img class="layer" data-start="1280" src="assets/tx_her.png" alt="">
        <img class="layer" data-start="1380" src="assets/tx_bd.png" alt="">
        <img class="layer" data-start="1480" src="assets/tx_talk2.png" alt="">
        <img class="layer" data-start="1580" src="assets/tx_stepsimple.png" alt="">
        <img class="layer" data-start="1680" src="assets/st_step.png" alt="">
        <img class="layer" data-start="1780" src="assets/tx_step.png" alt="">
        <img class="layer" data-start="1880" src="assets/st_pick.png" alt="">
        <img class="layer" data-start="1980" src="assets/st_wal.png" alt="">
        <img class="layer" data-start="2080" src="assets/tx_cf.png" alt="">
        <img class="layer" data-start="2180" src="assets/tx_end01.png" alt="">
        <img class="layer" data-start="2280" src="assets/tx_end02.png" alt="">
        <img class="layer" data-start="2380" src="assets/button.png" alt="">

        <!-- 실제 클릭될 영역 (투명) -->
        <div id="goBtn" class="go-hit-area"></div>

      </div>
    </div>
  </div>

  <!-- 스크롤 공간 -->
  <div class="spacer" id="spacer"></div>

  <script>
    /***********************
     * ✅ 원본 레이아웃(캔버스) 고정 값
     ***********************/
    const CANVAS_W = 390;
    const CANVAS_H = 2912;

    /***********************
     * ✅ 레이어 등장 타이밍 튜닝
     ***********************/
    const REVEAL_AT = 0.85; // 화면 하단에서 조금 더 일찍 트리거 (모바일 가시성 확보)
    const LEAD = 50;        // 미리 등장 시키는 정도 조정

    /***********************
     * DOM
     ***********************/
    const frame = document.getElementById('frame');
    const stage = document.getElementById('stage');
    const spacer = document.getElementById('spacer');
    const layers = Array.from(document.querySelectorAll('.layer'));

    let MAX_TRANSLATE = 0;
    let lastWidth = 0;

    function layout() {
      const frameW = frame.clientWidth;
      const frameH = frame.clientHeight;

      // 너비가 크게 변한 경우에만 스페이서 높이 재계산 (주소창 무시용)
      const forceLayout = Math.abs(lastWidth - frameW) > 5;
      if (forceLayout || MAX_TRANSLATE === 0) {
        lastWidth = frameW;

        // 캔버스(390x2912)를 폭 기준으로 스케일한 stage 높이
        const scaledStageH = frameW * (CANVAS_H / CANVAS_W);
        stage.style.height = scaledStageH + 'px';

        // stage가 위로 올라갈 수 있는 최대 거리
        MAX_TRANSLATE = Math.max(0, scaledStageH - frameH);

        // ✅ 스크롤 길이 설정: 딱 마지막까지 도달하도록
        spacer.style.height = (Math.ceil(MAX_TRANSLATE) + frameH) + 'px';
      }

      // frame을 고정시키기 위해 wrap에 스타일 적용
      const mainWrap = document.getElementById('main-wrap');
      mainWrap.style.position = 'fixed';
      mainWrap.style.top = '0';
      mainWrap.style.width = '100%';
    }

    // 버튼 클릭 이벤트 리스너 추가
    function initEvents() {
      const goBtn = document.getElementById('goBtn');
      if (goBtn) {
        goBtn.addEventListener('click', () => {
          // 마지막까지 스크롤했는지 확인 (95% 이상)
          const y = window.scrollY || 0;
          if (y >= MAX_TRANSLATE * 0.95) {
            window.location.href = 'sticker.html';
          }
        });
      }
    }

    let isTicking = false;
    function updateScroll() {
      if (!isTicking) {
        requestAnimationFrame(() => {
          const y = window.scrollY || 0;

          // ✅ 끝에서 정확히 멈추도록 clamp
          const translateY = Math.min(y, MAX_TRANSLATE);
          stage.style.transform = `translate3d(0, ${-translateY}px, 0)`;

          // 레이어 등장 계산
          const frameW = frame.clientWidth;
          const scale = frameW / CANVAS_W;

          // 등장 트리거 지점 계산 (현재 스크롤 위치 + 화면 높이의 일정 비율)
          const currentRevealY = (translateY + frame.clientHeight * REVEAL_AT) / scale;

          for (const img of layers) {
            const start = Number(img.dataset.start || 0);
            if (start <= currentRevealY + LEAD) {
              img.classList.add('show');
            }
          }

          // 히트 영역 활성화 제어 (거의 끝까지 왔을 때만 노출)
          const goBtn = document.getElementById('goBtn');
          if (goBtn) {
            if (translateY >= MAX_TRANSLATE * 0.9) {
              goBtn.style.display = 'block';
            } else {
              goBtn.style.display = 'none';
            }
          }

          isTicking = false;
        });
        isTicking = true;
      }
    }

    window.addEventListener('resize', () => {
      layout();
      updateScroll();
    });

    // passive: true로 성능 확보
    window.addEventListener('scroll', updateScroll, { passive: true });

    // 초기 실행
    layout();
    updateScroll();
    initEvents();
  </script>
</body>

</html>