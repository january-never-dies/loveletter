<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>A Sequence</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; /* 스크롤 포기 */
      background: #000;
      -webkit-font-smoothing: antialiased;
      user-select: none; -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* 화면을 390x844 비율로 "꽉 차게(cover)" */
    #viewport {
      position: fixed;
      inset: 0;
      background: #000;
      overflow: hidden;
    }

    /* 캔버스는 화면 전체, 내부는 DPR 스케일 */
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #loading {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      z-index: 10;
      transition: opacity 250ms ease;
    }
    #loading.hide { opacity: 0; pointer-events: none; }

    #hint {
      position: absolute;
      left: 0;
      bottom: max(24px, env(safe-area-inset-bottom));
      width: 100%;
      text-align: center;
      color: rgba(255,255,255,0.7);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      letter-spacing: 0.2px;
      opacity: 0;
      transition: opacity 350ms ease;
      pointer-events: none;
      z-index: 5;
    }
    #hint.show { opacity: 1; }
  </style>
</head>

<body>
  <div id="loading">Loading…</div>

  <div id="viewport">
    <!-- 누적 합성(배경) -->
    <canvas id="base"></canvas>
    <!-- 페이드 인(상단) -->
    <canvas id="fade"></canvas>

    <div id="hint">탭해서 다음으로</div>
  </div>

  <script>
    // ✅ A는 a1~a13 (확장자 webp여도 OK)
    const A_SEQ = [
      "assets/a1.webp","assets/a2.webp","assets/a3.webp","assets/a4.webp","assets/a5.webp","assets/a6.webp",
      "assets/a7.webp","assets/a8.webp","assets/a9.webp","assets/a10.webp","assets/a11.webp","assets/a12.webp","assets/a13.webp"
    ];

    // 타이밍
    const HOLD_MS = 600;     // 한 장 유지 시간
    const FADE_MS = 700;     // 페이드 인 시간
    const GAP_MS  = 80;      // 로드 후 안정화

    // iOS 메모리: DPR 너무 키우면 캔버스 자체가 무거워짐 → 상한 걸기
    const DPR_CAP = 2;

    const loading = document.getElementById("loading");
    const hint = document.getElementById("hint");

    const base = document.getElementById("base");
    const fade = document.getElementById("fade");
    const bctx = base.getContext("2d", { alpha: false });
    const fctx = fade.getContext("2d");

    let done = false;
    let playing = false;

    // 390x844 기준(내부 기준 좌표)
    const DESIGN_W = 390;
    const DESIGN_H = 844;

    function resizeCanvases() {
      const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
      const w = Math.floor(window.innerWidth * dpr);
      const h = Math.floor(window.innerHeight * dpr);

      base.width = w; base.height = h;
      fade.width = w; fade.height = h;

      // 배경은 검정으로 채움
      bctx.setTransform(1,0,0,1,0,0);
      bctx.fillStyle = "#000";
      bctx.fillRect(0,0,w,h);

      fctx.setTransform(1,0,0,1,0,0);
      fctx.clearRect(0,0,w,h);
    }

    // "cover" 방식으로 이미지 한 장을 캔버스에 꽉 차게 그리기
    function drawCover(ctx, img, cw, ch) {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;

      // cover: 캔버스 비율을 채우도록 확대 후 중앙 크롭
      const scale = Math.max(cw / iw, ch / ih);
      const sw = cw / scale;
      const sh = ch / scale;
      const sx = (iw - sw) / 2;
      const sy = (ih - sh) / 2;

      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
    }

    function loadImage(src) {
      return new Promise((resolve) => {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = src;
      });
    }

    async function fadeInAndCommit(img) {
      const cw = base.width, ch = base.height;

      // fade 레이어 초기화
      fctx.setTransform(1,0,0,1,0,0);
      fctx.clearRect(0,0,cw,ch);

      // fade 레이어에 이미지 그리기
      fctx.globalAlpha = 1;
      if (img) drawCover(fctx, img, cw, ch);

      // 페이드 인 애니메이션: fade canvas 전체를 alpha로
      const t0 = performance.now();
      return new Promise((resolve) => {
        function tick(now) {
          const p = Math.min(1, (now - t0) / FADE_MS);

          // fade 캔버스를 매 프레임 그릴 필요 없이, alpha만 조절해서 composite
          // (여기서는 fade 캔버스 자체를 clear->redraw 하지 않고, alpha composite를 위해
          //  'fade 캔버스 위에 아무것도 안 올리고' alpha로 덮는 방식은 어렵기 때문에,
          //  fade 캔버스의 내용은 고정 + 전체 alpha를 컨트롤하기 위해 clear 후 재그림)
          fctx.clearRect(0,0,cw,ch);
          fctx.globalAlpha = p;
          if (img) drawCover(fctx, img, cw, ch);

          if (p < 1) {
            requestAnimationFrame(tick);
          } else {
            // commit: base에 최종 이미지 합성(누적 유지)
            bctx.globalAlpha = 1;
            if (img) drawCover(bctx, img, cw, ch);

            // fade 레이어 비우기
            fctx.setTransform(1,0,0,1,0,0);
            fctx.clearRect(0,0,cw,ch);

            resolve();
          }
        }
        requestAnimationFrame(tick);
      });
    }

    async function playA() {
      playing = true;
      hint.classList.remove("show");

      for (let i = 0; i < A_SEQ.length; i++) {
        const img = await loadImage(A_SEQ[i]);
        await new Promise(r => setTimeout(r, GAP_MS));
        await fadeInAndCommit(img);

        // 마지막이면 멈추고 힌트
        if (i === A_SEQ.length - 1) break;
        await new Promise(r => setTimeout(r, HOLD_MS));
      }

      playing = false;
      done = true;
      hint.classList.add("show");
    }

    // 탭하면 다음 페이지(b.html)
    document.body.addEventListener("click", () => {
      if (!done || playing) return;
      // 캐시 문제 피하려면 ?v= 같은 쿼리 붙여도 됨
      location.href = "b.html";
    }, { passive: true });

    // init
    window.addEventListener("load", async () => {
      resizeCanvases();

      // 첫 장을 빠르게 보여주고 로딩 숨김
      const first = await loadImage(A_SEQ[0]);
      bctx.globalAlpha = 1;
      if (first) drawCover(bctx, first, base.width, base.height);

      loading.classList.add("hide");

      // 나머지(a2~a13) 페이드 + 누적
      if (A_SEQ.length > 1) {
        await new Promise(r => setTimeout(r, 250));
        for (let i = 1; i < A_SEQ.length; i++) {
          const img = await loadImage(A_SEQ[i]);
          await new Promise(r => setTimeout(r, GAP_MS));
          await fadeInAndCommit(img);
          if (i !== A_SEQ.length - 1) await new Promise(r => setTimeout(r, HOLD_MS));
        }
      }

      done = true;
      hint.classList.add("show");
    });

    window.addEventListener("resize", () => {
      // 회전/리사이즈 시 다시 그려야 하지만,
      // iOS 주소창 높이 변화로 매번 리렌더하면 부담이라 너비 변화 때만 권장.
      // 여기선 간단히 전체 리사이즈만 적용(필요하면 조건 추가 가능)
      const prevW = base.width;
      resizeCanvases();
      // NOTE: 리사이즈 후 누적을 다시 재구성하려면 A 이미지를 다시 재생해야 해서 생략.
      // 보통 iPhone 테스트는 세로 고정이라 문제 거의 없음.
    });
  </script>
</body>
</html>